<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: chapter.system.network.xml 515 2013-01-15 06:34:09Z netkiller $ -->
<chapter id="index"><?dbhtml dir="network" ?>
	<title>Networking 网络管理</title>
	<section id="hosts">
		<title>hosts</title>
		<screen>
		<![CDATA[
# cat -n /etc/hosts
     1  # Do not remove the following line, or various programs
     2  # that require network functionality will fail.
     3  127.0.0.1               development.domain.org development netkiller.localdomain netkiller
     4  ::1             localhost6.localdomain6 localhost6

		]]>
		</screen>

		<section>
			<title>/etc/hostname</title>
			<screen><![CDATA[
# cat /etc/hostname
web1.example.com
			]]></screen>
			<para>查看IP地址</para>
			<screen>
			<![CDATA[
[root@localhost ~]# hostname --ip-address
::1 127.0.0.1			
			]]>
			</screen>
		</section>
		<section>
			<title>hostnamectl - Control the system hostname</title>
			<screen><![CDATA[
[root@netkiller ~]# hostnamectl
   Static hostname: netkiller.localdomain
         Icon name: computer-desktop
           Chassis: desktop
        Machine ID: 072e88a0fdd2447296554f3cd5129076
           Boot ID: a978056f50544355abd723b328a89b6f
  Operating System: CentOS Linux 7 (Core)
       CPE OS Name: cpe:/o:centos:centos:7
            Kernel: Linux 3.10.0-229.el7.x86_64
      Architecture: x86_64
			]]></screen>
			<para>设置 hostname</para>
			<screen>
			<![CDATA[
[root@netkiller ~]# hostnamectl set-hostname master
			]]>
			</screen>
		</section>

		<section>
			<title>/etc/host.conf</title>
			<para>解析顺序配置文件</para>
			<screen><![CDATA[
[root@development bin]# cat /etc/host.conf
order hosts,bind
			]]></screen>
			<para>首先在/etc/hosts文件中寻找，如果不存在，再去DNS服务器中寻找</para>
		</section>
		<section>
			<title>/etc/hosts</title>
			<para>IP地址后面TAB符，然后写主机地址</para>
			<screen><![CDATA[
127.0.0.1       localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
192.168.1.10	development.example.com development
			]]></screen>
		</section>
		<section>
			<title>hosts.allow / hosts.deny</title>
			<para>/etc/hosts.allow 和 /etc/hosts.deny</para>
			<para>许可IP／禁止IP，相当于黑白名单</para>
		</section>
		<section>
			<title>/etc/resolv.conf</title>
			<screen>
			<![CDATA[
search example.com
nameserver 208.67.222.222
nameserver 208.67.220.220
			]]>
			</screen>
		</section>

	</section>
	<section id="nic">
		<title>Network adapter 网络适配器</title>
		<command>ethtool eth1</command>
		<screen><![CDATA[
neo@shenzhen:~/doc/Linux/xhtml$ sudo ethtool eth1
Settings for eth1:
        Supported ports: [ TP MII ]
        Supported link modes:   10baseT/Half 10baseT/Full
                                100baseT/Half 100baseT/Full
        Supports auto-negotiation: Yes
        Advertised link modes:  10baseT/Half 10baseT/Full
                                100baseT/Half 100baseT/Full
        Advertised auto-negotiation: Yes
        Speed: 100Mb/s
        Duplex: Full
        Port: MII
        PHYAD: 32
        Transceiver: internal
        Auto-negotiation: on
        Supports Wake-on: pumbg
        Wake-on: d
        Current message level: 0x00000007 (7)
        Link detected: yes
		]]></screen>
		<command>mii-tool</command>
		<screen><![CDATA[
neo@shenzhen:~/doc/Linux/xhtml$ sudo mii-tool
eth1: negotiated 100baseTx-FD, link ok
		]]></screen>

		<section id="nic.name">
			<title>接口名称</title>
			<para>Linux网卡默认接口名称是eth0，如果你想定义其他名称可以更改下面文件。</para>
			<para>/etc/udev/rules.d/70-persistent-net.rules</para>
			<screen><![CDATA[
cat /etc/udev/rules.d/70-persistent-net.rules

# This file maintains persistent names for network interfaces.
# See udev(7) for syntax.
#
# Entries are automatically added by the 75-persistent-net-generator.rules
# file; however you are also free to add your own entries.

# PCI device 0x10ec:0x8136 (r8169)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:1d:92:f0:37:58", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"
			]]></screen>
			<para>双网卡实例</para>
			<screen><![CDATA[
# cat /etc/udev/rules.d/70-persistent-net.rules
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.

# PCI device 0x8086:0x10d3 (e1000e)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:25:90:35:91:36", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"

# PCI device 0x8086:0x10d3 (e1000e)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:25:90:35:91:37", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"
			]]></screen>
		</section>

	</section>
	<section id="interfaces">
		<title>Ethernet Interfaces 以太网接口</title>

		<para>restart</para>
		<screen><![CDATA[
sudo /etc/init.d/networking restart
		]]></screen>
		<section id="interfaces.ifquery">
			<title>ifquery</title>
			<screen><![CDATA[
$ sudo ifquery --list
lo
eth0
eth1
			]]></screen>
		</section>
		<section id="interfaces.dhcp">
			<title>DHCP</title>
			<para>DHCP</para>
			<screen><![CDATA[
sudo vi /etc/network/interfaces

# The primary network interface - use DHCP to find our address
auto eth0
iface eth0 inet dhcp
			]]></screen>

		</section>
		<section id="interfaces.static">
			<title>Static IP</title>
			<para>Static IP</para>
			<screen><![CDATA[
# The primary network interface
auto eth0
iface eth0 inet static
address 192.168.3.90
gateway 192.168.3.1
netmask 255.255.255.0
network 192.168.3.0
broadcast 192.168.3.255

dns-nameservers 8.8.8.8 4.4.4.4
			]]></screen>
			<para>Setting up Second IP address or Virtual IP address in Ubuntu</para>
			<screen><![CDATA[
sudo vi /etc/network/interfaces

auto eth0:1
iface eth0:1 inet static
address 192.168.1.60
netmask 255.255.255.0
network x.x.x.x
broadcast x.x.x.x
gateway x.x.x.x

dns-nameservers 8.8.8.8 4.4.4.4
			]]></screen>
		</section>
	</section>

	<section id="mask">
		<title>Mask 子网掩码</title>
		<literallayout>
		<![CDATA[
举例说明该算法。
例：给定一 class c address : 192.168.5.0 ，要求划分20个子网，每个子网5个主机。
解：因为4 <5 < 8 ，用256－8＝248 ---->即是所求的子网掩码，对应的子网数也就出来了。这是针对C类地址。
针对B类地址的做法。对于B类地址，假如主机数小于或等于254，与C类地址算法相同。对于主机数大于254的，如需主机 700台，50个子网（相当大了），512 < 700< 1024
256－（1024/256）=256－4＝252 ---->即是所求的子网掩码，对应的子网数也就出来了。上面256－4中的4（2的2次幂）是指主机数用2进制表示时超过8位的位数，即超过2位，掩码为剩余的前6位，即子网数为2（6）－2＝62个。
		]]>
		</literallayout>
		<screen><![CDATA[
Append :Host/Subnet Quantities Table

----------------------------------------------------------------------
Class A                   Effective  Effective
# bits        Mask         Subnets     Hosts
-------  ---------------  ---------  ---------
  2      255.192.0.0            2      4194302
  3      255.224.0.0            6      2097150
  4      255.240.0.0           14      1048574
  5      255.248.0.0           30       524286
  6      255.252.0.0           62       262142
  7      255.254.0.0          126       131070
  8      255.255.0.0          254        65536
  9      255.255.128.0        510        32766
  10     255.255.192.0       1022        16382
  11     255.255.224.0       2046         8190
  12     255.255.240.0       4094         4094
  13     255.255.248.0       8190         2046
  14     255.255.252.0      16382         1022
  15     255.255.254.0      32766          510
  16     255.255.255.0      65536          254
  17     255.255.255.128   131070          126
  18     255.255.255.192   262142           62
  19     255.255.255.224   524286           30
  20     255.255.255.240  1048574           14
  21     255.255.255.248  2097150            6
  22     255.255.255.252  4194302            2

Class B                   Effective  Effective
# bits        Mask         Subnets     Hosts
-------  ---------------  ---------  ---------
  2      255.255.192.0           2     16382
  3      255.255.224.0           6      8190
  4      255.255.240.0          14      4094
  5      255.255.248.0          30      2046
  6      255.255.252.0          62      1022
  7      255.255.254.0         126       510
  8      255.255.255.0         254       254
  9      255.255.255.128       510       126
  10     255.255.255.192      1022        62
  11     255.255.255.224      2046        30
  12     255.255.255.240      4094        14
  13     255.255.255.248      8190         6
  14     255.255.255.252     16382         2

Class C                   Effective  Effective
# bits        Mask         Subnets     Hosts
-------  ---------------  ---------  ---------
  2      255.255.255.192      2         62
  3      255.255.255.224      6         30
  4      255.255.255.240     14         14
  5      255.255.255.248     30          6
  6      255.255.255.252     62          2

*Subnet all zeroes and all ones excluded.
*Host all zeroes and all ones excluded.
		]]></screen>
	</section>

	<section id="gateway">
		<title>Gateway 设置默认网关</title>
		<para>default gateway</para>
		<screen><![CDATA[
$ sudo route add default gw 172.16.0.1
		]]></screen>
		<screen><![CDATA[
$ sudo ip route default via 172.16.0.1 dev eth0
		]]></screen>
	</section>
	&section.network.dns.xml;
	<section id="forwarding">
		<title>IP forwarding(IP转发)</title>
		<para>enable IP forwarding</para>
		<screen><![CDATA[
neo@shenzhen:~$ sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1
		]]></screen>
		<screen><![CDATA[
# enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
		]]></screen>
		<para>ubuntu</para>
		<screen><![CDATA[
sysctl -w net.ipv4.ip_forward=1
		]]></screen>
	</section>
	<section id="bonding">
		<title>bonding</title>
		<para>绑定的前提条件：芯片组型号相同，而且网卡应该具备自己独立的BIOS芯片。</para>
		<command>#vi ifcfg-bond0</command>
		<screen><![CDATA[
# cat ifcfg-bond0
DEVICE=bond0
BOOTPROTO=static
IPADDR=172.16.0.1
NETMASK=255.255.252.0
BROADCAST=172.16.3.254
ONBOOT=yes
TYPE=Ethernet
		]]></screen>
		<para>这里要主意，不要指定单个网卡的IP 地址、子网掩码。将上述信息指定到虚拟适配器(bonding)中即可</para>
		<screen><![CDATA[
[root@rhas-13 network-scripts]# cat ifcfg-eth0
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=dhcp

[root@rhas-13 network-scripts]# cat ifcfg-eth1
DEVICE=eth1
ONBOOT=yes
BOOTPROTO=dhcp
		]]></screen>
		<para>编辑 /etc/modules.conf 文件，加入如下一行内容，以使系统在启动时加载bonding模块，对外虚拟网络接口设备为 bond0.加入下列两行:</para>
		<command>* /etc/modules.conf 文件已经不再使用</command>
		<screen>
		<![CDATA[
cat >> /etc/modprobe.d/bonding.conf <<EOF
alias bond0 bonding
options bond0 miimon=100 mode=1
EOF
        ]]>
		</screen>
		<para>
			说明：miimon是用来进行链路监测的。比如:miimon=100，那么系统每100ms监测一次链路连接状态，如果有一条线路不通就转入另一条线路；mode的值表示工作模式，他共有0， 1,2,3四种模式，常用的为0,1两种。mode=0表示load balancing (round-robin)为负载均衡方式，两块网卡都工作。mode=1表示fault-tolerance (active-backup)提供冗余功能，工作方式是主备的工作方式,也就是说默认情况下只有一块网卡工作,另一块做备份。bonding只能提供链路监测，即从主机到交换机的链路是否接通。如果只是交换机对外的链路down掉了，而交换机本身并没有故障，那么bonding会认为链路没有问题而继续使用。
		</para>

		<command># vi /etc/rc.d/rc.local</command>
		<screen><![CDATA[
ifenslave bond0 eth0 eth1
route add -net 172.31.3.254 netmask 255.255.255.0 bond0
		]]></screen>

		<para>到这时已经配置完毕 重新启动机器。重启会看见以下信息就表示配置成功了</para>
		<screen><![CDATA[
................
Bringing up interface bond0 OK
Bringing up interface eth0 OK
Bringing up interface eth1 OK
................
		]]></screen>
		<para>mode=1工作在主备模式下,这时eth1作为备份网卡是no arp的 [root@rhas-13 network-scripts]# ifconfig 验证网卡的配置信息</para>
		<para>那也就是说在主备模式下,当一个网络接口失效时(例如主交换机掉电等),不回出现网络中断, 系统会按照cat /etc/rc.d/rc.local里指定网卡的顺序工作,机器仍能对外服务,起到了失效保护的功能。在mode=0 负载均衡工作模式,他能提供两倍的带宽,下我们来看一下网卡的配置信息：</para>
		<para>在这种情况下出现一块网卡失效,仅仅会是服务器出口带宽下降,也不会影响网络使用。通过查看bond0的工作状态查询能详细的掌握bonding的工作状态</para>
		<para>Linux下通过网卡邦定技术既增加了服务器的可靠性,又增加了可用网络带宽,为用户提供不间断的关键服务。</para>
		<section>
			<title>Ubuntu</title>
			<para>ifenslave</para>
			<screen><![CDATA[
apt-get install ifenslave-2.6
			]]></screen>
			<para>/etc/modules</para>
			<screen><![CDATA[
bonding
			]]></screen>
			<para>modprobe bonding</para>

			<para>/etc/modprobe.d/aliases</para>
			<screen><![CDATA[
alias bond0 bonding
options bonding mode=0 miimon=100

or

options bonding mode=1 miimon=100 downdelay=200 updelay=200
			]]></screen>
			<example>
				<title>bonding example</title>
				<para>/etc/network/interfaces</para>
				<screen><![CDATA[
auto lo
iface lo inet loopback

iface eth0 inet dhcp
iface eth1 inet dhcp

auto bond0
iface bond0 inet static
address 172.16.0.1
netmask 255.255.255.0
gateway 172.16.0.254
up ifenslave bond0 eth0 eth1
down ifenslave -d bond0 eth0 eth1
				]]></screen>
			</example>
		</section>
	</section>

	<section id="wireless">
		<title>Wireless - WiFi 配置</title>
		<section>
			<title>rfkill - tool for enabling and disabling wireless devices</title>
			<screen><![CDATA[
$ rfkill list all
0: phy0: Wireless LAN
	Soft blocked: no
	Hard blocked: yes
			]]></screen>
			<para>锁定无线设备</para>
			<screen><![CDATA[
$ rfkill block 0

$ rfkill list 
0: phy0: Wireless LAN
	Soft blocked: yes
	Hard blocked: yes			
			]]></screen>
			<para>解锁无线设备</para>
			<screen><![CDATA[
$ rfkill unblock all

$ rfkill list all
0: phy0: Wireless LAN
	Soft blocked: no
	Hard blocked: yes
			]]></screen>
		</section>
		<section>
			<title>iwlist - Get more detailed wireless information from a wireless interface</title>
			<screen><![CDATA[
$ sudo iwlist wlan1 scanning |more

wlan1     Scan completed :
          Cell 01 - Address: 04:A1:51:99:0A:25
                    Channel:1
                    Frequency:2.412 GHz (Channel 1)
                    Quality=43/70  Signal level=-67 dBm  
                    Encryption key:on
                    ESSID:"szgw-p5"
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                              9 Mb/s; 12 Mb/s; 18 Mb/s
                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s
                    Mode:Master
                    Extra:tsf=0000000904486387
                    Extra: Last beacon: 1068ms ago
                    IE: Unknown: 0007737A67772D7035
                    IE: Unknown: 010882848B960C121824
                    IE: Unknown: 030101
                    IE: Unknown: 0706434E20010D14
                    IE: IEEE 802.11i/WPA2 Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (2) : CCMP TKIP
                        Authentication Suites (1) : PSK
                    IE: WPA Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (2) : CCMP TKIP
                        Authentication Suites (1) : PSK
                    IE: Unknown: 2A0100
                    IE: Unknown: 32043048606C
                    IE: Unknown: DD180050F20201018D0003A4000027A4000042435E0062322F00
                    IE: Unknown: DD1E00904C33CE111BFFFF000000000000000000000000000000000000000000
                    IE: Unknown: 2D1ACE111BFFFF000000000000000000000000000000000000000000
                    IE: Unknown: DD1A00904C34010D0A00000000000000000000000000000000000000
                    IE: Unknown: 3D16010D0A00000000000000000000000000000000000000
                    IE: Unknown: 4A0E14000A002C01C800140005001900
                    IE: Unknown: 7F0101
                    IE: Unknown: DD0900037F01010000FF7F
                    IE: Unknown: DD0A00037F04010000004000

			]]></screen>
			<para>搜索SSID</para>
			<screen><![CDATA[
$ sudo iwlist wlan1 scanning | grep ESSID
                    ESSID:"product"
                    ESSID:"wifi123456"
                    ESSID:"ChinaNet-zNNs"
                    ESSID:"ChinaNet-dqar"
                    ESSID:"360WiFi-SEM"
                    ESSID:"360\xE5\x85\x8D\xE8\xB4\xB9WiFi-A5"
                    ESSID:"\xE5\x8F\x96\xE4\xB8\xAA\xE4\xBB\x80\xE4\xB9\x88\xE5\x90\x8D\xE5\xAD\x97\xE5\x91\xA2\xEF\xBC\x9F"
                    ESSID:""
                    ESSID:""			
			]]></screen>
		</section>

		<section>
			<title>iwconfig - configure a wireless network interface</title>
			<screen>
			<![CDATA[
$ sudo iwconfig eth1 essid <ESSID> key <PASSWORD>			
			]]>
			</screen>
		</section>
		<section>
			<title>/proc/net/wireless</title>
			<screen><![CDATA[
$ cat /proc/net/wireless
Inter-| sta-|   Quality        |   Discarded packets               | Missed | WE
 face | tus | link level noise |  nwid  crypt   frag  retry   misc | beacon | 22			
			]]></screen>
		</section>
		<example>
			<title>命令行建立WiFi链接步骤</title>
			<screen><![CDATA[
$ sudo rfkill unblock all
$ sudo ifconfig wlan1 up
$ sudo iwlist wlan1 scanning | grep ESSID
$ sudo iwconfig wlan1 essid Netkiller key 66535215
			]]></screen>
		</example>
	</section>

	<section id="sys.net.centos">
		<title>CentOS 网络配置</title>
		<command>system-config-network</command>
		<screen><![CDATA[
ifconfig eth0 192.168.0.10 netmask 255.255.255.0
or
ip addr add 192.168.0.10 dev eth0
		]]></screen>
		<para>ifcfg-eth0,ifcfg-eth1,ifcfg-eth2 ... ifcfg-eth(n)</para>
		<screen>
		<![CDATA[
[root@development httpd]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
# Broadcom Corporation NetLink BCM5784M Gigabit Ethernet PCIe
DEVICE=eth0
BOOTPROTO=static
BROADCAST=192.168.3.255
HWADDR=00:25:64:A3:59:BF
IPADDR=192.168.3.40
IPV6INIT=yes
IPV6_AUTOCONF=yes
NETMASK=255.255.255.0
NETWORK=192.168.3.0
ONBOOT=yes
		]]>
		</screen>
		<para>eth0:1</para>
		<screen>
		<![CDATA[
[root@development httpd]# cp /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0:1
[root@development httpd]# vi /etc/sysconfig/network-scripts/ifcfg-eth0:1
# Broadcom Corporation NetLink BCM5784M Gigabit Ethernet PCIe
DEVICE=eth0:1
BOOTPROTO=static
BROADCAST=192.168.3.255
HWADDR=00:25:64:A3:59:BF
IPADDR=192.168.3.41
IPV6INIT=yes
IPV6_AUTOCONF=yes
NETMASK=255.255.255.0
NETWORK=192.168.3.0
ONBOOT=yes
		]]>
		</screen>
		<para>reload network</para>
		<screen>
		<![CDATA[
[root@development ~]# /etc/init.d/network reload
Shutting down interface eth0:                              [  OK  ]
Shutting down loopback interface:                          [  OK  ]
Bringing up loopback interface:                            [  OK  ]
Bringing up interface eth0:
		]]>
		</screen>

		<section id="gateway">
			<title>Gateway</title>
			<screen>
			<![CDATA[
[root@development ~]# cat /etc/sysconfig/network
NETWORKING=yes
NETWORKING_IPV6=yes
HOSTNAME=development.domain.org
GATEWAY=192.168.3.1
			]]>
			</screen>
		</section>

		<section id="bonding">
			<title>bonding</title>
			<screen>
		    <![CDATA[
cat >> /etc/modprobe.d/bonding.conf <<EOF
alias bond0 bonding
options bond0 mode=balance-alb miimon=1000
EOF

cat > /etc/sysconfig/network-scripts/ifcfg-eth0 <<EOF
DEVICE="eth0"
ONBOOT="yes"
BOOTPROTO="none"
USERCTL="no"
NM_CONTROLLED="no"
EOF

cat > /etc/sysconfig/network-scripts/ifcfg-eth1 <<EOF
DEVICE="eth1"
ONBOOT="yes"
BOOTPROTO="none"
USERCTL="no"
NM_CONTROLLED="no"
EOF

cat > /etc/sysconfig/network-scripts/ifcfg-bond0 <<EOF
DEVICE="bond0"
ONBOOT="yes"
BOOTPROTO="none"
TYPE="Ethernet"
IPADDR=172.16.0.5
NETMASK=255.255.255.0
NETWORK=172.16.0.0
USERCTL="no"
NM_CONTROLLED="no"
EOF

modprobe bonding mode=balance-alb miimon=1000
ifconfig bond0 up
ifconfig bond0 172.16.0.5 netmask 255.255.255.0 up
ip route add default via 172.16.0.254 dev bond0
ifenslave bond0 eth0
ifenslave bond0 eth1

cat >> /etc/rc.local <<EOF
#-------------------------
ifenslave bond0 eth0
ifenslave bond0 eth1
ip route add default via 172.16.0.254 dev bond0
#-------------------------
EOF

more /proc/net/bonding/bond0
			]]>
			</screen>
		</section>

		<section id="brctl">
			<title>brctl</title>
			<para>Linux 系统4个物理网卡的名称则分别为eth0，eth1，eth2，eth3。我们将四个网口桥接到br0端口。</para>
			<para>你可以这样理解 vlan 2, vlan ip 192.168.0.1，然后将4个接口划分到vlan2, 这时这4个接口可以通过vlan 2访问其他用户。我只是做了一个比喻，让你能够理解。</para>
			<screen><![CDATA[
	
			]]></screen>
			<screen><![CDATA[
# brctl addbr br0

# brctl addif br0 eth0
# brctl addif br0 eth1
# brctl addif br0 eth2
# brctl addif br0 eth3

# ifconfig eth0 0.0.0.0
# ifconfig eth1 0.0.0.0
# ifconfig eth2 0.0.0.0
# ifconfig eth3 0.0.0.0

# ifconfig br0 192.168.0.1
			]]></screen>
		</section>
	</section>
	<section id="network.check">
		<title>网络检查命令</title>
		<section id="ping">
			<title>ping</title>
			<screen>
			<![CDATA[
-f: 发送洪水请求,每个请求打印一个点,每个响应删除一个点.如果网络存在丢包,那么会呈现出一长串不断增加的点.

-n: 选项,加上之后可以阻止ping程序去进行反向dns查询
    当每次ping完得到响应之后,ping程序会尝试一次反向dns查询(reverse dns lookup)来获取“64 bytes from”后面的域名,如果查询速度很慢的话,就会给人似乎延迟很大的感觉,其实这也是ping感觉慢,但是每次ping的响应时间却并不慢的原因.
			]]>
			</screen>
		</section>
		<section id="mtu">
			<title>Finding optimal MTU</title>
			<screen>
			<![CDATA[
$ ping -c 1 -s $((1500-28)) -M do www.debian.org
PING www.debian.org (140.112.8.139) 1472(1500) bytes of data.
1480 bytes from linux3.cc.ntu.edu.tw (140.112.8.139): icmp_seq=1 ttl=47 time=52.7 ms

--- www.debian.org ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 52.778/52.778/52.778/0.000 ms
			]]>
			</screen>
			<para>Try 1454 instead of 1500</para>
		</section>
		<section id="ss">
			<title>ss - another utility to investigate sockets</title>
			<screen>
			<![CDATA[
ss是Socket Statistics的缩写
    ss命令可以用来获取socket统计信息,它可以显示和netstat类似的内容;但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息,而且比netstat更快速更高效.
    
    当服务器的socket连接数量变得非常大时,无论是使用netstat命令还是直接cat /proc/net/tcp,执行速度都会很慢;ss快的秘诀在于,它利用到了TCP协议栈中 tcp_diag . tcp_diag是一个用于分析统计的模块, 用netfilter来获取第Linux内核中第一手的信息,这就确保了ss的快捷高效;如果你的系统中没有tcp_diag,ss也可以正常运行,只是效率会变得稍慢.
    
    netstat命令是net-tools工具集中的一员,而ss命令是iproute工具集中的一员.
    yum install iproute iproute-doc


#### ss过滤器

ss的过滤器分为两种:
     state
         状态:established,syn-sent,syn-recv,fin-wait-1,fin-wait-2,time-wait,closed,close-wait,last-ack,listen,closing
         除了这13种状态之外,还有几个聚类的状态:
             all – for all the states
             bucket – 显示状态为maintained as minisockets,如：time-wait和syn-recv
             big – 和bucket相反
             connected – 除了listen and closed的所有状态
             synchronized – 所有已连接的状态除了syn-sent
     addr+port
         地址和端口可以使用表达式,类似于tcpdump中的用法,关键字有:
             dst ADDRESS_PATTERN – matches remote address and port
             src ADDRESS_PATTERN – matches local address and port
             dport RELOP PORT – compares remote port to a number
             sport RELOP PORT – compares local port to a number
             autobound – checks that socket is bound to an ephemeral port

#### ss usage

ss [ OPTIONS ] [ FILTER ]
        OPTIONS:
            -p 显示每个进程的名字和pid
            -s 列出当前socket详细信息
            -n 不解析服务名称
            -r 解析主机名
            -a 显示所有套接字(sockets)
            -o 显示计时器信息(timer)
            -l 显示监听状态的套接字(sockets)
            -e 显示详细的套接字(sockets)信息
            -m 显示套接字(sockets)的内存使用情况
            -i 显示 TCP内部信息
            -4 仅显示IPv4的套接字(sockets)
            -6 仅显示IPv6的套接字(sockets)
            -0 显示 PACKET 套接字(sockets)
            -t 仅显示 TCP套接字(sockets)
            -u 仅显示 UCP套接字(sockets)
            -d 仅显示 DCCP套接字(sockets)
            -w 仅显示 RAW套接字(sockets)
            -x 仅显示 Unix套接字(sockets)
            -f --family=FAMILY  显示 FAMILY类型的套接字(sockets),FAMILY可选,支持 unix, inet, inet6, link, netlink
            -D --diag=FILE     将原始TCP套接字(sockets)信息转储到文件
            -F --filter=FILE   从文件中都去过滤器信息 FILTER := [ state TCP-STATE ] [ EXPRESSION ]

#### Recv And Send

[root@netkiller ~]# ss -anp | column -c1
State      Recv-Q Send-Q        Local Address:Port          Peer Address:Port
LISTEN     0      128               127.0.0.1:9000                     *:*      users:(("php-fpm",1481,9),("php-fpm",1482,0),("php-fpm",1483,0),("php-fpm",1484,0),("php-fpm",1485,0),("php-fpm",1486,0),("php-fpm",1487,0),("php-fpm",1488,0),("php-fpm",1489,0),("php-fpm",1490,0),("php-fpm",1491,0))
LISTEN     0      50                        *:3306                     *:*      users:(("mysqld",2680,11))
LISTEN     0      128                       *:443                      *:*      users:(("nginx",1743,8),("nginx",1744,8),("nginx",1745,8))
LISTEN     0      128              10.1.17.17:2812                     *:*      users:(("monit",2030,6))
TIME-WAIT  0      0                 127.0.0.1:43251            127.0.0.1:80
TIME-WAIT  0      0                 127.0.0.1:43248            127.0.0.1:80
ESTAB      0      0                10.1.17.17:22              10.1.17.18:51752  users:(("sshd",3122,3))
ESTAB      0      0                10.1.17.17:22              10.1.20.70:51531  users:(("sshd",19093,3))

处于LISTEN状态的socket:
    Recv-Q表示了current listen backlog队列元素数目(等待用户调用accept的完成3次握手的socket)
    Send-Q表示了listen socket最大能容纳的backlog.这个数目由listen时指定,且不能大于 /proc/sys/net/ipv4/tcp_max_syn_backlog;
    
对于非LISTEN socket:
    Recv-Q表示了receive queue中的字节数目(等待接收的下一个tcp段的序号-尚未从内核空间copy到用户空间的段最前面的一个序号)
    Send-Q表示发送queue中容纳的字节数(已加入发送队列中最后一个序号-输出段中最早一个未确认的序号)


#### Sockets State
>1 Listen


[root@netkiller ~]# ss -lnp | column -c1
State      Recv-Q Send-Q        Local Address:Port          Peer Address:Port
LISTEN     0      128               127.0.0.1:9000                     *:*      users:(("php-fpm",1481,9),("php-fpm",1482,0),("php-fpm",1483,0),("php-fpm",1484,0),("php-fpm",1485,0),("php-fpm",1486,0),("php-fpm",1487,0),("php-fpm",1488,0),("php-fpm",1489,0),("php-fpm",1490,0),("php-fpm",1491,0))
LISTEN     0      50                        *:3306                     *:*      users:(("mysqld",2680,11))
LISTEN     0      50                        *:3307                     *:*      users:(("mysqld",2564,11))

>2 Established


[root@netkiller ~]# ss -onp state established | column -c1
Recv-Q Send-Q             Local Address:Port               Peer Address:Port
0      0                     10.1.17.17:22                   10.1.17.18:51752  timer:(keepalive,70min,0) users:(("sshd",3122,3))
0      0                     10.1.17.17:22                   10.1.20.70:51531  timer:(keepalive,69min,0) users:(("sshd",19093,3))

>3 Sockets Summary


[root@netkiller ~]# ss -s
Total: 93 (kernel 150)
TCP:   106 (estab 10, closed 88, orphaned 0, synrecv 0, timewait 88/0), ports 41

Transport Total     IP        IPv6
*	  150       -         -
RAW	  0         0         0
UDP	  1         1         0
TCP	  18        18        0
INET	  19        19        0
FRAG	  0         0         0

>4 Expand


1 显示所有状态为established的ssh连接
[root@netkiller ~]# ss -o state established '( dport = :ssh or sport = :ssh )'
Recv-Q Send-Q                                      Local Address:Port                                          Peer Address:Port
0      0                                              10.1.17.17:ssh                                             10.1.17.18:51752    timer:(keepalive,109min,0)
0      0                                              10.1.17.17:ssh                                             10.1.20.70:51531    timer:(keepalive,103min,0)

#### ***timer user mem rto*** 

------在另外一个终端执行 ssh 10.1.2.103-----
然后在本终端执行如下命令
[root@netkiller ~]# ss -eimpn '( dport = :22 )' -o
State      Recv-Q Send-Q                                                          Local Address:Port                                                            Peer Address:Port
ESTAB      0      0                                                                   10.1.2.23:44107                                                             10.1.2.103:22     timer:(keepalive,28min,0) users:(("ssh",9545,4)) ino:21970248 sk:ffff88013c2e5900
	 mem:(r0,w0,f4096,t0) sack cubic wscale:7,8 rto:203 rtt:3.25/1.75 ato:40 cwnd:10 send 35.9Mbps rcv_rtt:33427 rcv_space:113592
	 
------在另外一个终端执行 telnet 27.111.200.86 15672-----
然后在本终端执行如下命令
[root@netkiller ~]# ss -eimpn '( dport = :15672 )' -o
State      Recv-Q Send-Q                                                          Local Address:Port                                                            Peer Address:Port
ESTAB      0      2                                                                   10.1.2.23:57531                                                          27.111.200.86:15672  timer:(on,614ms,0) users:(("telnet",10163,4)) ino:21983807 sk:ffff8800378ba040
	 mem:(r0,w554,f3542,t0) sack cubic wscale:7,8 cwnd:10 rcv_space:14600

> timer


-o 显示计时器信息(timer),linux对一个tcp socket总共有7个定时器,通过4个timer实现
    通过icsk_retransmit_timer实现的重传定时器,零窗口探测定时器;
    通过sk_timer实现的连接建立定时器,保活定时器和FIN_WAIT_2定时器;
    通过icsk_delack_timer实现的延时ack定时器以及TIME_WAIT定时器.
    
timer 这个输出描述的是tcp socket上的定时器
timer 的输出含义就是(类型,过期时间,重试次数)
    off: 当前socket没有timer
    on: 重传timer
    keepalive：连接建立timer or fin_wait_2 timer or 保活timer;具体是那个timer,可以根据连接的状态来确定.
    timewait: TIME_WAITtimer
    persist：零窗口探测timer 

> user


ss -p 输出users项里会出现三个参数:
    第一个是进程名
    第二个为pid
    第三项该进程文件描述符的使用数量

> mem


mem:(r0,w554,f3542,t0)
r  the read (inbound) buffer
w  the write (outbound) buffer
f  the "forward allocated memory" (memory available to the socket)
t  the transmit queue (stuff waiting to be sent or waiting on an ACK)

> socket information


sack cubic wscale
rto
rtt
cwnd
send
rcv_space

#### Notice
>1 ss process name and pid


only name

ss -tp | grep -v Recv-Q | sed -e 's/.*users:(("//' -e 's/".*$//' | sort | uniq

only  pid
[root@netkiller ~]# ss -tp | grep -v Recv-Q | sed -e 's/.*users:((.*",//' -e 's/,.*$//'  | sort | uniq

name  and pid
# ss -tp | grep -v Recv-Q | sed -e 's/.*users:(("\(.*\)",\(.*\),.*$/\1:\2/' | sort | uniq
f_e_related_dat:4695
mysqld:4289
salt-minion:4001
sshd:25161
		
			]]>
			</screen>
		</section>
	</section>
	<section id="netplan">
		<title>Ubuntu netplan (Ubuntu 18.04 之后才用 netplan 管理网络)</title>
		<para>https://netplan.io/examples 参考例子</para>
		<para>配置 DHCP</para>
		<example>
			<title>netplan dhcp 例子</title>
			<screen>
			<![CDATA[
neo@netkiller ~ % cat /etc/netplan/interfaces.yaml 
network:
  version: 2
  renderer: networkd
  ethernets:
    enp2s1:
      dhcp4: true			
			]]>
			</screen>
			<para>启用生效</para>
			<screen>
			<![CDATA[
neo@netkiller ~ % sudo netplan apply			
			]]>
			</screen>

		</example>

	</section>
	&section.network.router.xml;
</chapter>
