<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: chapter.nginx.faq.xml 654 2013-07-30 07:30:20Z netkiller $ -->
<section id="faq">
	<title>FAQ</title>
	<section id="405">
		<title>405 Not Allowed?</title>
		<qandaset>
			<qandaentry>
				<question>
					<para>405 Not Allowed?</para>
				</question>
				<answer>
					<para>静态页面POST会提示405 Not Allowed错误.</para>
					<screen>
					<![CDATA[
# curl -d name=neo http://www.mydoamin.com/index.html
<html>
<head><title>405 Not Allowed</title></head>
<body bgcolor="white">
<center><h1>405 Not Allowed</h1></center>
<hr><center>nginx</center>
</body>
</html>
					]]>
					</screen>
					<screen>
server {
    listen       80 default;
    server_name  myid.mydomain.com;

    charset utf-8;
    access_log  /var/log/nginx/myid.mydomain.com.access.log  main;

    if ($http_user_agent ~* ^$){
      return 412;
    }
    ###########################

    location / {
        root   /www/mydomain.com/myid.mydomain.com;
        index  index.html index.php;
        #error_page 405 =200 $request_filename;
    }

    #error_page  404              /404.html;
    #
    error_page 405 =200 @405;
    location @405 {
        #proxy_set_header  Host            $host;
        proxy_method GET;
        proxy_pass http://myid.mydomain.com;

    }


    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
					</screen>
				</answer>
			</qandaentry>
		</qandaset>
	</section>
	<section id="502">
		<title>502 Bad Gateway?</title>
		<qandaset>
			<qandaentry>
				<question>
					<para>502 Bad Gateway</para>
					<para>error.log 提示：</para>
					<para>upstream sent too big header while reading response header from upstream?</para>
				</question>
				<answer>
					<para>修改fastcgi配置</para>
					<screen>
location ~ \.php$ {

	fastcgi_buffers 8 16k;
	fastcgi_buffer_size 32k;
	。。。
	。。。
}
					</screen>
				</answer>
			</qandaentry>
		</qandaset>
	</section>
	
	<section id="413">
		<title>413 Request Entity Too Large</title>
		<qandaset>
			<qandaentry>
				<question>
					<para>413 Request Entity Too Large</para>
					<para>error.log 提示：</para>
					<para>client intended to send too large body</para>
				</question>
				<answer>
					<para>client_max_body_size 8m;</para>
					<para>修改 /etc/nginx/nginx.conf 文件。</para>
					<screen>
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    server_tokens off;
    gzip  on;
    gzip_min_length 1k;
    gzip_types text/plain text/html text/css application/javascript text/javascript application/x-javascript text/xml application/xml application/xml+rss application/json;
    gzip_vary on;

    client_max_body_size 8m;

    include /etc/nginx/conf.d/*.conf;
}
					</screen>
				</answer>
			</qandaentry>
		</qandaset>
	</section>	
	
	<section id="proxy_pass.regular">
		<title>nginx: [emerg] "proxy_pass" cannot have URI part in location given by regular expression</title>
		<qandaset>
			<qandaentry>
				<question>
					<para>nginx: [emerg] "proxy_pass" cannot have URI part in location given by regular expression, or inside named location, or inside "if" statement, or inside "limit_except" block in /etc/nginx/conf.d/info.mydomain.com.conf:112?</para>
					<para>nginx: configuration file /etc/nginx/nginx.conf test failed</para>
				</question>
				<answer>
					<para>使用$request_uri变量可以解决上述问题.</para>
					<screen>
       if ( $request_uri ~ "^/\w+\.xml$") {
            proxy_pass http://www.mydomain.com/xml$request_uri;
			break;
       }

       if ( $request_uri ~ "^/public/datas/\w+\.xml$") {
            proxy_pass http://www.mydomain.com/$request_uri;
			break;
       }
					</screen>
				</answer>
			</qandaentry>
		</qandaset>
	</section>
	<section id="faq.proxy_pass">
		<title>proxy_pass</title>
		<screen>
nginx: [emerg] "proxy_pass" cannot have URI part in location given by regular expression, or inside named location, or inside "if" statement, or inside "limit_except" block in /etc/nginx/conf.d/www.mydomain.com.conf:25
nginx: configuration file /etc/nginx/nginx.conf test failed
		</screen>
		<para>在location,if中使用证则匹配proxy_pass末尾不能写/</para>
		<screen>
	if ($request_uri ~* "^/info/{cn|tw}/{news|info}/\d\.html") {
		proxy_pass http://info.example.com/;
		break;
	}

    location ~ ^/info/ {
                proxy_pass http://info.example.com/;
                break;
    }
		</screen>
		<para>proxy_pass http://info.example.com/; 改为  proxy_pass http://info.example.com; 可以解决</para>
	</section>
	<section id="session">
		<title>proxy_pass SESSION 丢失问题</title>
		<para>如果用户Cookie信息没有经过 proxy_pass 传递给最终服务器，SESSION信息将丢失，解决方案</para>
		<screen>
proxy_set_header   Cookie $http_cookie;
		</screen>
	</section>
	<section id="faq.worker_rlimit_nofile">
		<title>[alert] 55785#0: *11449 socket() failed (24: Too many open files) while connecting to upstream</title>
		<para>配置 worker_rlimit_nofile 参数即可</para>
		<screen>
user  nginx;
worker_processes  8;
worker_rlimit_nofile 65530;
		</screen>
		<para>配置 ulimit 也能达到同样效果，但我更喜欢 worker_rlimit_nofile 因为它仅仅作用于nginx,而不是全局配置。</para>
	</section>
	<section id="faq.server_name">
		<title>server_name 与 SSI 注意事项</title>
		<screen>
server_name www.example.com www.example.net www.example.org;
		</screen>
		<para>下来SSI标签无论你使用那个域名访问，输出永远是server_name的第一域名www.example.com</para>
		<screen>
		<![CDATA[
<!--#echo var="SERVER_NAME"-->
		]]>
		</screen>
		<para>需要通过SERVER_NAME判定展示不同结果时需要注意。</para>
	</section>
	<section id="faq.location">
		<title>location 跨 document_root 引用，引用 document_root 之外的资源</title>
		<para>下面的例子是 Document root 是 /www/netkiller.com/m.netkiller.com， 我们需要 /www/netkiller.com/www.netkiller.com 中的资源。</para>
		<screen>
		<![CDATA[
server {
    listen       80;
    server_name  m.netkiller.com;

    charset utf-8;
    access_log  /var/log/nginx/m.netkiller.com.access.log;
    error_log  /var/log/nginx/m.netkiller.com.error.log;

    location / {
		root /www/netkiller.com/m.netkiller.com;
		index.html
    }

    location /module {
        root /www/netkiller.com/www.netkiller.com;
    }	

}

		]]>
		</screen>
		<screen>
		<![CDATA[
server {
    listen       80;
    server_name  m.netkiller.com;

    charset utf-8;
    access_log  /var/log/nginx/m.netkiller.com.access.log;
    error_log  /var/log/nginx/m.netkiller.com.error.log;

    location / {
		root /www/netkiller.com/m.netkiller.com;
		index.html
    }

    location ^~ /module/ {
        root /www/netkiller.com/www.netkiller.com;
    }	

}
		]]>
		</screen>
		<para>上面的例子location /module 是指 /www/netkiller.com/www.netkiller.com + /module，如果  /www/netkiller.com/www.netkiller.com 目录下面没有 module 目录是出现404， error.log显示 "/www/netkiller.cn/www.netkiller.cn/module/index.html" failed (2: No such file or directory)</para>
	</section>
</section>